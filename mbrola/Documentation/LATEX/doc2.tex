%% This LaTeX-file was created by <pagel> Fri Apr  7 15:39:55 2000
%% LyX 0.12 (C) 1995-1998 by Matthias Ettrich and the LyX Team

%% Do not edit this file unless you know what you are doing.
\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}

\makeatletter


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\newcommand{\LyX}{L\kern-.1667em\lower.25em\hbox{Y}\kern-.125emX\spacefactor1000}
\newcommand{\noun}[1]{\textsc{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newcommand{\lyxrightaddress}[1]{
  \par {\raggedleft \begin{tabular}{l}\ignorespaces
  #1
  \end{tabular}
  \vspace{1.4em}
  \par}
}

\makeatother

\begin{document}


\title{MBROLA }


\date{(Multi-Band Resynthesis OverLap Add)}


\date{System documentation}


\date{Edition 7.0 - Mbrola release 3.02}


\date{March 12th, 2000}

\maketitle
~

\begin{quote}
\char`\"{}It would be a considerable invention indeed, that of a machine able
to mimic speech, with its sounds and articulations. I think it is not impossible.\char`\"{}
Leonhard Euler (1761)

~
\end{quote}

\lyxrightaddress{by Vincent Pagel and Thierry Dutoit\\
}

~

\tableofcontents

~


\section{MBROLA Sources General condition of use}

The source code of MBROLA may only be used to produce the object code sold by
your company. It is confidential and should remain safely locked, as well as
its documentation.


\section{A brief description of MBROLA}

MBROLA v3.01 is a speech synthesizer based on the concatenation of diphones.
One synthesis channel takes a list of phonemes as input, together with prosodic
information (duration of phonemes and a piecewise linear description of pitch),
and produces speech samples on 16 bits (linear), at the sampling frequency of
the diphone database. It is therefore \noun{not} a Text-To-Speech synthesizer,
since it does not accept raw text as input.

It is distributed as a ZIP file whose name respect the format \emph{\char`\"{}mbrXXXX.zip\char`\"{}}
where \emph{XXXX} represent the version number (e.g. \emph{"mbr3.01e.zip"}).\\


It may be compiled in 3 modes depending on which stream drives the process: 

\begin{itemize}
\item Driven by the input phonetic file: it is compiled as a standalone program named
\char`\"{}synth\char`\"{} which outputs audio in a file or a pipe. This mode
is a good choice under Unix platforms for end-user applications. In the following
we call this mode \textbf{\char`\"{}}\textbf{\emph{standalone mode}}\char`\"{}.
\item Driven by the audio output: compiled as a library, which outputs audio data
into buffers of the size, requested by the main program. This allows you to
easily include MBROLA inside your TTS application without temporary file mechanisms.
In the following we call this mode \char`\"{}\textbf{\emph{library mode}}\char`\"{}. 
\item Same as above, included in a DLL for Windows95-98/NT (which is of course the
preferred mode for Windows platforms). In the following we call this mode \char`\"{}\textbf{\emph{DLL
mode}}\char`\"{}. 
\end{itemize}
While using \emph{library} or \emph{DLL} mode, we now differentiate one channel
and multi channel mbrola. In the first mode, one database is associated to one
and only one synthesis channel, which generally fits for end-user applications.
In the second mode, one can run many synthesis channel instantiations with one
or more Database instances and many phonetic input streams. This second solution
is adapted to multi channel telecom TTS applications.

~

In all those compilation modes MBROLA requires a language/voice database to
run properly. For your internal use (i.e. non-commercial) you can test the voices
made available on the MBROLA project homepage:

~

http://tcts.fpms.ac.be/synthesis

~

Refer to your contract to check your rights for commercial exploitation of the
different Diphone Databases.

~


\section{Distribution}

Since release 3.01, Mbrola has been transformed into pure ANSI/C code, and object
like programming with a strong encapsulation of data (strong because we have
respected the fences we put!). One file in the distribution is generally equivalent
to one object (pointer on struct). You can find an exhaustive description in
the programmer's section 6.

This distribution of MBROLA contains the following files: 

\begin{description}
\item [Makefile:]Unix makefile for Gnu Make (gmake command)
\item [~]~
\item [DOCUMENTATION/Programmer/documentation302:]this document
\item [DOCUMENTATION/Programmer/HISTORY.txt:]history of revisions
\item [DOCUMENTATION/User/readme.txt:]standalone version manual
\item [~]~
\item [Database:]handling of different database formats 
\item [Database/database.c:]functions to read diphones in the speech database
\item [Database/database.h]~
\item [Database/database\_bacon.c:]functions to read compressed diphone databases
\item [Database/database\_bacon.h]~
\item [Database/database\_old.c:]functions to read diphone databases older than 2.06
\item [Database/database\_old.h]~
\item [~]~
\item [Database/diphone\_info.c:]description of the diphone structures
\item [Database/diphone\_info.h]~
\item [~]~
\item [Database/hash\_tab.c:]hash table of DiphoneInfo (access to the diphone database)
\item [Database/hash\_tab.h]~
\item [~]~
\item [Database/little\_big.c:]handles the little and big endian numeric conversions
\item [Database/little\_big.h]~
\item [~]~
\item [Database/rename\_list.c:]list of phoneme pairs (used for renaming and cloning)
\item [Database/rename\_list.h]~
\item [~]~
\item [Parser:]functions to read phonemes in the input stream
\item [Parser/fifo.c:]First In First Out with chars
\item [Parser/fifo.h]~
\item [Parser/input.h:]define abstract input stream 
\item [Parser/input\_fifo.c:]\textbf{i}nstantiation of input.h with Fifo
\item [Parser/input\_fifo.h]~
\item [Parser/input\_file.c:]instantiation of input.h with File
\item [Parser/input\_file.h]~
\item [Parser/parser.h:]define abstract phoneme parser
\item [Parser/parser\_input.c:]instantiation of parser.h with Input
\item [Parser/parser\_input.h]~
\item [Parser/phonbuff.c:]handle a phoneme buffer for pitch interpolation
\item [Parser/phonbuff.h]~
\item [Parser/phone.c:]phoneme type
\item [Parser/phone.h]~
\item [~]~
\item [Engine:]Mbrola synthesis engine
\item [Engine/diphone.c:]diphone with info for synthesis
\item [Engine/diphone.h]~
\item [Engine/mbrola.c:]mbrola algorithm (Ola, Smoothing...)
\item [Engine/mbrola.h]~
\item [~]~
\item [Misc:]Miscellaneous functions basically unrelated to synthesis 
\item [Misc/audio.c:]audio output and audio file header (au, wav, aiff, raw)
\item [Misc/audio.h]~
\item [Misc/common.c:]useful little functions (uppercase, swab...)
\item [Misc/common.h]~
\item [Misc/g711.c:]G711 audio coding (ALAW and MULAW)
\item [Misc/g711.h]~
\item [Misc/incdll.h:]external definitions used outside of the Mbrola package
\item [Misc/mbralloc.c:]memory allocators are here and ONLY here
\item [Misc/mbralloc.h]~
\item [Misc/vp\_error.c:]deals with fatal error and warnings
\item [Misc/vp\_error.h:]macros for debugging purposes
\item [~]~
\item [Standalone:]Standalone compilation front-end
\item [Standalone/Posix]~
\item [Standalone/Posix/getopt.c:]provided for non-POSIX Unixes
\item [Standalone/Posix/getopt.h]~
\item [Standalone/synth.c:]front-end for the compilation in the standalone mode. Main()
\item [Standalone/synth.h]~
\item [LibOneChannel:]library providing one MBROLA synthesis channel
\item [LibOneChannel/demo1.c:]small demonstration program running with the library 
\item [LibOneChannel/demo1b.c:]small demo showing error handling with the library
\item [LibOneChannel/onechannel.c:]library providing one mbrola channel at a time
\item [LibOneChannel/onechannel.h]~
\item [LibOneChannel/lib1.c:]wrapper file to build the library lib1.c (mono channel)
\item [~]~
\item [LibMultiChannel:]library for multi MBROLA synthesis channel for telecom
\item [LibMultiChannel/multichannel.c:]many synthesis channel from one dba
\item [LibMultiChannel/multichannel.h]~
\item [LibMultiChannel/demo2.c:]demo using lib2
\item [LibMultiChannel/lib2.c:]wrapper file to build the library lib2.c (multi channel)
\item [~]~
\item [VisualC++:]compilation projects for Microsoft Visual C++
\item [VisualC++/DLL:]Visual C++ project to build the DLL
\item [VisualC++/DLL\_USE:]sample program using the DLL
\item [VisualC++/Standalone:]Visual C++ project to build a standalone binary
\item [~]~
\item [Bin:]directory containing the output of the compilation with Make under Unix
architectures.
\end{description}

\section{Installation and Tests~ }


\subsection{On Unix}

You must first unzip the distribution file mbrXXXX.zip where XXXX stand for
the version number:

\begin{description}
\item [unzip]mbrXXXX.zip
\item [Mbrola]can be compiled with the 'gmake' (gnu make) command on the following
platforms:
\end{description}
\begin{itemize}
\item SUN Sparc 5/S5R4 (Solaris2.4)
\item HPUX9.0 and HPUX10.0 
\item VAX/VMS V6.2 (V5.5-2 won't work)
\item DECALPHA(AXP)/VMS 6.2
\item AlphaStation 200 4/233
\item AlphaStation 200 4/166
\item IBM RS6000 Aix 4.12
\item PC/LINUX 1.2.11
\item PCPentium120/Solaris2.4
\item OS/2
\item BeBox
\item QNX OS
\end{itemize}
Though, as Mbrola is written in standard ANSI/C, we also support POSIX compliant
UNIX Platforms. Please send acknowledgment when Mbrola works on a machine/system
not listed here. Before you compile anything you must define some symbols depending
on the architecture you're working with:

\begin{description}
\item [LITTLE\_ENDIAN]® 80x86 based platforms
\item [BIG\_ENDIAN]® motorola or HP based platforms 
\item [VMS]® VAX/VMS stations
\item [DOS]® PC80x86 with Dos or Windows
\item [SUN4]® old Sun4 stations (not Posix compliant)
\item [DEBUG]® Huge debugging flag
\item [DEBUG\_HASH]® Runs the database and print info about the hash table management
(used to tune the memory management of the database)
\item [According]to the compilation mode you wish, you can comment or uncomment following
lines of Makefile : 
\end{description}
\begin{quote}
\#CFLAGS += -DDEBUG

\#CFLAGS += -DDEBUG\_HASH

\#CFLAGS += -DLITTLE\_ENDIAN

CFLAGS += -DBIG\_ENDIAN
\end{quote}
You can add any definitions to the CFLAGS (compilation flags) variable of the
Makefile, as in the following example:

\begin{description}
\item [optimized]compilation on a Sun Station :
\end{description}
\begin{quote}
CFLAGS= -Wall -DBIG\_ENDIAN -O6
\end{quote}
\begin{description}
\item [debug]mode on a VAX/VMS :
\end{description}
\begin{quote}
CFLAGS= -Wall -DLITTLE\_ENDIAN -DVMS -g -DDEBUG
\end{quote}
By default the compiler is set with CC = gcc ; though on many platforms cc may
also work. As the hardware manufacturer generally provides cc, it is preferred
when possible since the object code performance can be higher by an order of
magnitude. You can type :

\begin{description}
\item [\char`\"{}make\char`\"{}]or \char`\"{}make all\char`\"{} to generate the 'synth'
binary (standalone mode).
\item [\char`\"{}make]clean\char`\"{} removes the entire object files and binaries.
\item [\char`\"{}make]lib1\char`\"{} compiles lib1.c in the library mode (one channel
synth)
\item [\char`\"{}make]demo1\char`\"{} builds a demo exemplifying the use of lib1
\item [\char`\"{}make]lib2\char`\"{} compiles lib1.c in the library mode (multi channel
synth)
\item [\char`\"{}make]demo2\char`\"{} builds a demo exemplifying the use of lib2
\item [\char`\"{}make]tags\char`\"{} to build Emacs popular tags (helps finding your
way through the code with ESC-. ). SUN Workshop uses an internal btags program
for that purpose.
\end{description}
The intermediate object code goes into a Bin directory that is created on the
occasion.


\subsection{On PCs/Dos}

On PC/Dos platforms, use \char`\"{}pkunzip synthXXXX.zip\char`\"{} to restore
the files (don't forget to restore the embedded paths in the archive). Mbrola
can be compiled with Microsoft Visual C++ (4 .0 or higher), or Borland C++ (4
.5 or higher), on the following platforms:

\begin{itemize}
\item PC486/DOS6 (but other PC/DOS should do, too)
\item PC486/Windows 3.1
\item PC486/Windows 95 
\item PC-Pentium/Windows 98
\item PC-Pentium/Windows NT
\end{itemize}
Always check that in your project the following preprocessor directives are
defined: LITTLE\_ENDIAN and DOS. A project to build such a release with Visual
C++ is provided under VisualC++/Standalone.


\subsection{On PC/Windows}

First proceed like for the PC/DOS platforms. Once synthXXXX is installed you
can start building a DLL in the VisualC++\char`\\{}DLL directory. MbrolaDll.dsw
is a Microsoft VisualC++ 5.0 project file to build a DLL. In any project you
make to build a DLL with Mbrola don't forget to define the DLL, LITTLE\_ENDIAN,
DOS preprocessor definitions.

The Mbrola source files and a wrapper DLL interface is included in the project,
it should compile smoothly. In case you have to build a new project from scratch
remember that you should include only file from either LibOneChannel/ or LibMultiChannel/.
Never include files from Standalone/, as this directory is only relevant for
a standalone mode (see section above for an exe binary).

Several compilation modes are available, the \char`\"{}Win32 Bacon Static\char`\"{}
is a good one to start with (Bacon compression scheme is included, DLL are statically
linked).

In the directory VisualC++/DLL\_USE , little sample programs are given that
use the Mbrola DLL.


\subsubsection{Black magic}

There is a strange bug in Visual C++ 5.0, when you compile the project you sometime
get:

\begin{quote}
Linking...

nafxcw.lib(dllmodul.cbj) : error LNK2005: \_DllMain@12 already defined in LIBCMT.lib(dllmain.cbj)

nafxcw.lib(afxmem.cbj) : error LNK2005: \char`\"{}void {*} \_\_cdecl operator
new(unsigned int)\char`\"{} (??2@YAPAXI@Z) already defined in LIBCMT.lib(new.cbj)

nafxcw.lib(afxmem.cbj) : error LNK2005: \char`\"{}void \_\_cdecl operator delete(void
{*})\char`\"{} (??3@YAXPAX@Z) already defined in LIBCMT.lib(delete.cbj)

nafxcw.lib(dllmodul.cbj) : warning LNK4006: \_DllMain@12 already defined in
LIBCMT.lib(dllmain.cbj); second definition ignored

nafxcw.lib(afxmem.cbj) : warning LNK4006: \char`\"{}void {*} \_\_cdecl operator
new(unsigned int)\char`\"{} (??2@YAPAXI@Z) already defined in LIBCMT.lib(new.cbj);
second definition ignored

nafxcw.lib(afxmem.cbj) : warning LNK4006: \char`\"{}void \_\_cdecl operator
delete(void {*})\char`\"{} (??3@YAXPAX@Z) already defined in LIBCMT.lib(delete.cbj);
second definition ignored

Creating library MbrolaDl/Mbrola.lib and object MbrolaDl/Mbrola.exp

Output\char`\\{}Release\_Static\char`\\{}Mbrola.dll : fatal error LNK1169: one
or more multiply defined symbols found

Error executing link.exe.

Mbrola.dll - 4 error(s), 7 warning(s)
\end{quote}
Solution: remove one file from the project and include it again in the list
of source files, and build the project again. The problem vanishes.


\subsection{Using the standalone binary}

You are now ready to test the program. First try: \char`\"{}synth\char`\"{}
to get an information screen about the copyright. Then, for a help screen on
how to use the standalone version of the software, try :

\begin{quotation}
synth -h 
\end{quotation}
You get a help screen like the following:

\begin{quotation}
> USAGE: ./synth {[}COMMAND LINE OPTIONS{]} database pho\_file+ output\_file

>

>A - instead of pho\_file or output\_file means stdin or stdout

>Extension of output\_file ( raw, au, wav, aiff ) tells the wanted audio format

>

> Options can be any of the following:

> -i = display the database information if any

> -e = IGNORE fatal errors on unknown diphone

> -c CC = set COMMENT char (escape sequence in pho files)

> -F FC = set FLUSH command name

> -v VR = VOLUME ratio, float ratio applied to ouput samples

> -f FR = FREQ ratio, float ratio applied to pitch points

> -t TR = TIME ratio, float ratio applied to phone durations

> -l VF = VOICE freq, target freq for voice quality

> -R RL = Phoneme RENAME list of the form a A b B ...

> -C CL = Phoneme CLONE list of the form a A b B ...

> 

> -I IF = Initialization file containing one command per line

> CLONE, RENAME, VOICE, TIME, FREQ, VOLUME, FLUSH, 

> COMMENT, and IGNORE are available
\end{quotation}
Now in order to go further, you need to get a version of an MBROLA language/voice
database from the MBROLA project homepage. Let us assume you have copied the
FR1 database and referred to the accompanying fr1.txt file for its installation.
Then try: 

\begin{quotation}
synth fr1/fr1 fr1/TEST/bonjour.pho bonjour.wav
\end{quotation}
it uses the format:

\begin{quotation}
synth diphone\_database command\_file1 command\_file2 ... output\_file
\end{quotation}
and creates a sound file for the word 'bonjour' (Hello! in French)

~

Basically the output file is composed of signed integer numbers on 16 bits,
corresponding to samples at the sampling frequency of the MBROLA voice/language
database (16 kHz for the diphone database supplied by the authors of MBROLA
: Fr1). MBROLA can produce different audio file formats: .au, .wav, .aiff, .aif,
and .raw files depending on the ouput\_file extension. If the extension is not
recognized, the format is RAW (no header). We recommend .wav for Windows, and
.au for Unix platforms. To display information about the phoneme set used by
the database, type:

\begin{quotation}
synth -i fr1/fr1
\end{quotation}
It displays the phonetic alphabet as well as copyright information about the
database. 

~

Option -e makes Mbrola ignore wrong or missing diphone sequences (replaced by
silence) which can be quite useful when debugging your TTS. Equivalent to \char`\"{}IGNORE\char`\"{}
directive in the initialization file (N.B replace the obsolete ;;E=OFF , unsupported
in .pho file).


\subsubsection{Changing the pitch}

Optional parameters let you shorten or lengthen synthetic speech and transpose
it by providing optional time and frequency ratios:

\begin{quotation}
synth -t 1.2 -f 0.8 -v 0.7 fr1/fr1 TEST/bonjour.pho bonjour.wav
\end{quotation}
or its equivalent in the initialization file:

\begin{quotation}
TIME 1.2

FREQ 0.8
\end{quotation}
for instance, will result in a RIFF Wav file bonjour.wav 1.2 times longer than
the previous one (slower rate), and containing speech in which all fundamental
frequency values have been multiplied by 0.8 (sounds lower). You can also set
the values of these coefficients directly in a .pho file by adding special escape
sequence like :

\begin{quotation}
;; F=0.8

;; T=1.2
\end{quotation}
You can change the voice characteristics with the -l parameter. If the sampling
rate of your database is 16000, indicating -l 18000 allows you to shorten the
vocal tract by a ratio 16/18 (children voice, or women voice depending on the
voice you're working on). With -l 10000,you can lengthen the vocal tract by
a ratio 18/10 (namely the voice of a Troll). The same command in an initialization
file becomes \char`\"{}VOICE 10000\char`\"{}.

~

Option \textbf{-v} gives a VolumeRatio that multiplies each output sample. In
the example below, each sample is multiplied by 0.7 (the loudness goes down).
Warning: setting VolumeRatio too high generates saturation.

\begin{quotation}
synth -v 0.7 fr1/fr1 TEST/bonjour.pho bonjour.wav
\end{quotation}
or add the line \textbf{\char`\"{}VOLUME 0.7\char`\"{}} in an initialization
file

~

The \textbf{-c} option lets you specify which symbol will be used as an escape
sequence for comments and commands in .pho files. The default value is the semi-colon
';', but you may want to change this if your phonetic alphabet use this symbol,
like in:

\begin{quotation}
synth -c ! fr1/fr1 TEST/test1.pho test2.pho test.wav
\end{quotation}
equivalent to \char`\"{}\textbf{COMMENT !}\char`\"{} in an initialization file

~

The \textbf{-F} option lets you specify which symbol will be used to Flush the
audio output. The default value is \textbf{\#}, you may want to change the symbol
like in:

\begin{quotation}
mbrola -F FLUSH\_COMMAND fr1/fr1 test.pho test.wav
\end{quotation}
equivalent to \char`\"{}\textbf{FLUSH FLUSH\_COMMAND}\char`\"{} in the initialization
file.


\subsubsection{Using Pipes}

A - instead of command\_file or output\_file means stdin or stdout. On multitasking
machines, it is easy to run the synthesizer in real time to obtain audio output
from the audio device, by using pipes.


\subsubsection{Renaming and Cloning phonemes}

It may happen that the language-processing module connected to MBROLA doesn't
use the same phonemic alphabet as the voice used. The Renaming and Cloning mechanisms
help you to quickly solve such problems (without adding extra CPU load). The
only limitation about phoneme names is that they can't contain blank characters.

~

If, for instance, phoneme a in the mbrola voice you use is called my\_a in your
alphabet, and phoneme b is called my\_b, then the following command solves the
problem:

\begin{quotation}
synth -R \char`\"{}a my\_a b my\_b\char`\"{} fr1/fr1 test.pho test.wav
\end{quotation}
You can give as many renaming pairs as you want. Circular definition is not
a problem. E.g. \char`\"{}\textbf{a b b c}\char`\"{} will rename original \emph{{[}a{]}}
into {[}b{]} and original \emph{{[}b{]}} into \emph{{[}c{]}} independently \emph{({[}a{]}}
won't be renamed to \emph{{[}c{]}}).

~

LIMITATION: you can't rename a phoneme into another that already exists.

~

The cloning mechanism does exactly the same thing, though the old phoneme still
exists after renaming. This is useful if you have 2 allophones in your alphabet,
but the Mbrola voice only provides one.

~

Imagine for instance, that you make the distinction between the voiced {[}r{]}
and its unvoiced counterpart {[}r0{]} and that you are using a syllabic version
{[}r={]}. If as a first approximation using {[}r{]} for both is OK, then you
may use an Mbrola voice that only provides one version of {[}r{]} by running:

\begin{quotation}
synth -C \char`\"{}r r0 r r=\char`\"{} fr1/fr1 test.pho test.wav
\end{quotation}
which tells the synthesizer that {[}r0{]} and {[}r={]} should be both synthesized
as {[}r{]}. You can write a long cloning list of phoneme pairs to fit your needs. 

~

Renaming and cloning eats CPU since the complete diphone hash table has to be
rebuilt, but once the renaming or cloning has occurred there is absolutely NO
RELATED PERFORMANCE DROP. So using this feature is more efficient than a pre-processor
is, though a simple phoneme mapping cannot always solve incompatibilities.

~

Before renaming anything as \textbf{\#}, check section 5.1.2

~

When one has long cloning and renaming lists, you can conveniently write them
into an initialization file according to the following format:

\begin{quotation}
RENAME a my\_a

RENAME b my\_b

CLONE r r0

CLONE r r=
\end{quotation}
The obsolete \char`\"{}\textbf{;; RENAME a my\_a}\char`\"{} can't be used in
.pho file anymore, but is correctly parsed in initialization files. Note to
EN1 and MRPA users: the consequence of the change above is that you must change
the previous call format \char`\"{}\emph{mbrola en1 en1mrpa...}\char`\"{} into
\char`\"{}\emph{mbrola -I en1mrpa en1 ...}\char`\"{}.


\subsection{Machine dependant hints for best using Mbrola}




\subsubsection{On MSDOS}



With the standalone version, generating wav files is easier:



\begin{quotation}
synth fr1/fr1 TEST/bonjour.pho bonjour.wav
\end{quotation}


Then you can play the RIFF Wav file with your favorite DOS or Windows sound
utility. On OS/2 pipes may be used just like below.


\subsubsection{On modern Unix systems such as Solaris or HPUX or Linux}

Type:

\begin{quotation}
synth fr1 bonjour.pho -.au | audioplay
\end{quotation}
where audioplay is your audio file player ({*} the name vary with the platform,
e.g. splayer for HPUX {*}).

If your audioplayer has problems with sun .AU files, try with .wav or .raw.
Never use .wav format when you pipe the output (mbrola can't rewind the file
to write the audio size in the header). Wav format was not developed for Unix
(on the contrary Au format let you specify in the header \char`\"{}we're on
a pipe, read until end of file\char`\"{}). 

~

NOTE FOR LINUX: you can use the GPL rawplay program provided at

\begin{quotation}
ftp://tcts.fpms.ac.be/pub/mbrola/pclinux/
\end{quotation}

\subsubsection{On Sun4 ( old audio interface )}

Those machines are now quite old and only provide a mulaw 8Khz output. A hack
is:

\begin{quotation}
synth fr1 input.pho - | sox -t raw -sw -r 16000 - -t raw -Ub -r 8000 - > /dev/audio
\end{quotation}
Provided you have the public domain sox utility developed by Ircam, you should
hear \emph{'bonjour'} without the need to create intermediate files. Note that
we strongly recommend that you DON'T use SOX, since its resampling method (linear
interpolation) will permanently damage the sound.

Other solution: The UTILITY.ZIP file available from the MBROLA homepage provides
RAW2SUN that does this conversion.


\subsubsection{On VAX or AXP workstations}

To make it easier for users to find MBROLA, you should add the following command
to your system startup procedure: 

\begin{quotation}
\$ DEFINE/SYSTEM/EXEC MBROLA\_DIR disk:{[}dir{]}
\end{quotation}
where \char`\"{}disk:{[}dir{]}\char`\"{} is the name of the directory you created
for the MBROLA\_DIR files. You could also add the following command to your
system login command procedure: 

\begin{quotation}
\$ MBROLA :== \$MBROLA\_DIR:MBROLA.EXE

\$ RAW2SUN :== \$MBROLA\_DIR:RAW2SUN.EXE
\end{quotation}
to use the decsound device:

\begin{quotation}
\$ MCR DECSOUND - volume 40 -play sound.au 
\end{quotation}
See also the MBR\_OLA.COM batch file in the UTILITY.ZIP file available from
the MBROLA Homepage if you cannot play 16 bits sound files on your machine. 


\subsection{Default Parser Manual}

The default parser is the parser that was provided before release 3.01. Implicitly
it means that you can replace it with your own one, thanks to the setParser\_MBR
function. Basically the work of the parser is to return to Mbrola a phoneme
with a length, and its pitch points.

~

We provide a default parser that allows you to give optional pitch points, the
intonation curve being linearly interpolated between those points.


\subsubsection{Input file format}

Example of a command line :

\begin{quotation}
synth fr1/fr1 bonjour.pho bonjour.wav 
\end{quotation}
For example the phonetic input file bonjour.pho simply contains : 

\begin{quotation}
; \textbf{Bonjour}

\_ \textbf{51 25 114}

b \textbf{62 }

o\~{} \textbf{127 48 170.42}

Z \textbf{110 53.5 116 }

u \textbf{211 }

R \textbf{150 50 91 }

\_ \textbf{91}
\end{quotation}
This shows the format of the input data required by MBROLA. Each line contains
a phoneme name, a duration (in ms), and a series (possibly none) of pitch pattern
points composed of two float numbers each: the position of the pitch pattern
point within the phoneme (in \% of its total duration), and the pitch value
(in Hz) at this position.

~

Hence, the second line of bonjour.pho : 

\begin{quotation}
\_ 51 25 114 
\end{quotation}
tells the synthesizer to produce a silence of 51 ms, and to put a pitch pattern
point of 114 Hz at 25\% of 51 ms. Pitch pattern points define a piecewise linear
pitch curve. Notice that the pitch pattern they define is continuous, since
the program automatically drops pitch information when synthesizing unvoiced
phones.

~

Blank characters or tabs separate the data on each line. Comments can optionally
be introduced in command files, starting with a semi-colon \textbf{';'}. This
default can be overrun with the \textbf{-c} option of the command line.

~

Another special escape sequence \textbf{';;'} allow the user to introduce commands
in the middle of .pho files as described below. This escape sequence is also
affected by the \textbf{-c} option.


\subsubsection{Changing the Frequency Ratio or Time Ratio}

A command escape sequence containing a line like \textbf{\char`\"{}T=x.x\char`\"{}}
modifies the time ratio to \textbf{x.x}, the same result is obtained on the
fundamental frequency by replacing T with F, like in:

\begin{quotation}
;; T = 1.2

;;F=0.8
\end{quotation}

\subsubsection{Flush the output stream}

Note, finally, that the synthesizer outputs chunks of synthetic speech determined
as sections of the piecewise linear pitch curve. Phones inside a section of
this curve are synthesized in one go. The last one of each chunk, however, cannot
be properly synthesized while the next phone is not known (since the program
uses diphones as base speech units). When using mbrola with pipes, this may
be a problem. Imagine, for instance, that mbrola is used to create a pipe-based
speaking clock on a HP:

\begin{quotation}
speaking\_clock | mbrola fr1 - -.au | splayer
\end{quotation}
which tells the time, say, every 30 seconds. The last phone of each time announcement
will only be synthesized when the next announcement starts. To bypass this problem,
mbrola accepts a special command phone, which flushes the synthesis buffer :
\char`\"{}\textbf{\#}\char`\"{}

This default character can be replaced by another symbol thanks to the command:

\begin{quotation}
;; FLUSH new\_flush\_symbol
\end{quotation}
Another important issue with piping under UNIX, is the possibility to prematurely
end the audio output, if for example the user presses the stop button of your
application. Since release 3.01, Mbrola handles signals.

~

If in the previous example the user wants to interrupt the speaking clock message,
the application just needs to send the USR1 signal. You can send such a signal
from the console with:

\begin{quotation}
kill -16 mbrola\_process\_number
\end{quotation}
Once mbrola catches the signal, it reads its input stream until it gets EOF
or a FLUSH command (hence, surrounding sections with flush is a good habit).


\subsubsection{Limitations of MBROLA}

There is no more limitation on the number of pitch points one can assign to
a phoneme, or on the number of phonemes without pitch points. There is no more
limitation on extra low pitch (sometime used to produce vocal fry).

Phonemes can be synthesized with a maximum duration that depends on the fundamental
frequency with which they are produced. The higher the frequency, the lower
the duration. For a frequency of 133 Hz, the maximum duration is 7.5 sec. For
a frequency of 66.5 Hz, is 5 sec. For a frequency of 266 Hz, is 3.75 sec.


\section{Programmer's Manual}

First, we describe in this section the object oriented philosophy used since
release 3.01.


\subsection{Philosophy and architecture}

Actually nothing (or nearly nothing) prevents us to program in standard C/ANSI
with an object like convention which authorize: 

\begin{enumerate}
\item \char`\"{}weak\char`\"{} encapsulation
\item Inheritance
\item Polymorphism
\end{enumerate}

\subsection{Encapsulation of Object's attributes}

Let's exemplify the programming conventions with the char Fifo found in Parser/fifo.h.
First we define a structure describing a Fifo.

\begin{quotation}
typedef struct 

\{

char{*} charbuff;~~~~~~~~~ /{*} circular buffer for phonetic input {*}/

int buffer\_pos;~~~~~~~~~~~~~~~~~ /{*} Current position {*}/

int buffer\_end;~~~~~~~~~~~~~~~~~ /{*} Last available phoneme {*}/

int buffer\_size;~~~~~~~~~~~~~~~~ /{*} number of chars in Phobuffer {*}/

\} Fifo;
\end{quotation}
To make distinction between public and private data, the convention is to never
directly access the features of a Fifo out of its fifo.c implementation file.
To reach this goal we exclusively access members through function-like macros.

\begin{quotation}
\#define charbuff(ff) ff->charbuff

\#define buffer\_pos(ff) ff->buffer\_pos

\#define buffer\_end(ff) ff->buffer\_end

\#define buffer\_size(ff) ff->buffer\_size
\end{quotation}
It allows the following: 

\begin{quotation}
Fifo{*} my\_fifo; 

..

int length= buffer\_size(my\_fifo);
\end{quotation}
The programmer should not cheat to discover whether buffer\_size is a function
or a macro, thus encapsulating the data and making them independent of the Fifo's
real implementation (modulo a complete recompiling). C is not C++ and your compiler
won't be able to carry out strong type checking just as with inline functions,
that's the reason why attributes don't respect the full convention below (according
to our conventions we should have use the name buffer\_size\_Fifo() ).

The methods always respect the format: functionname\_ObjectName just like below
and take a pointer on the object as a first argument. Methods beginning with
init are always constructor, and those beginning with close are destructors:

\begin{quotation}
Fifo{*} init\_Fifo(int size);

/{*}

~~{*} Constructor with size of the buffer

~~{*}/

void close\_Fifo(Fifo{*} ff); 

/{*}

~~{*} Release the memory

~~{*}/

void reset\_Fifo(Fifo{*} ff);

/{*}

~~{*} Forget previously entered data in the circular buffer

~~{*}/

int write\_Fifo(Fifo{*} ff, char {*}buffer\_in);

/{*}

~~{*} Write a string of phoneme in the input buffer

~~{*} Return the number of chars actually written

~~{*}/

int readline\_Fifo(Fifo{*} ff, char {*}line, int size);

/{*} 

~~{*} Read a line from the input stream in a circular buffer

~~{*} Return 0 if there's nothing to read

~~{*}/
\end{quotation}

\subsubsection{Inheritance and Polymorphism}

Inheritance alone can always be simulated through the is\_a\_client\_of relation,
the most interesting case being polymorphism. Polymorphism is interesting for
multiple format database handling, and live input parser definition inside of
the synthesizer.

~

The abstract type below specifies an Input object providing the methods close,
reset and readline .

\begin{quotation}
typedef struct Input Input;

typedef int ({*}readline\_InputFunction)(Input{*} in, char {*}line, int size);

typedef void ({*}close\_InputFunction)(Input{*} in);

typedef void ({*}reset\_InputFunction)(Input{*} in);

struct Input

\{

void{*} self;

readline\_InputFunction readline\_Input;

close\_InputFunction close\_Input;

close\_InputFunction reset\_Input;

\};
\end{quotation}
This type can be derived into Input\_File (the input stream is a file) or Input\_Fifo
(the input stream comes from a Fifo as described above). The part of the object
corresponding to the features overloaded on the basic Input type is stored in
the self part.

\begin{quotation}
\#include \char`\"{}input.h\char`\"{}

\#include \char`\"{}fifo.h\char`\"{}

static int readline\_InputFifo(Input{*} in, char {*}line, int size)

\{ return( readline\_Fifo((Fifo{*}) in->self,line,size) ); \}

static void reset\_InputFifo(Input{*} in)

\{ reset\_Fifo((Fifo{*}) in->self); \}

static void close\_InputFifo(Input{*} in)

\{ MBR\_free(in); \}

Input{*} init\_InputFifo(Fifo{*} my\_fifo)

\{

Input{*} self= (Input{*}) MBR\_malloc( sizeof(Input) );

self->self= (void{*}) my\_fifo;

self->readline\_Input= readline\_InputFifo;

self->close\_Input= close\_InputFifo;

self->reset\_Input= reset\_InputFifo;

return self;

\}
\end{quotation}

\subsubsection{Inheritance and cross-reference graph}

The Database, Input and Parser objects contain deferred (=virtual) methods and
thus allow polymorphism.


\section{Application Programming Interface}

The explanations given in the previous section are particularly useful to the
user who wants to design ad-hoc parsers. Though one can keep on working with
the default parser.


\subsection{One channel mode}

You can build a demo by running \char`\"{}\textbf{make demo1}\char`\"{} under
Unix, or simply build the library with \char`\"{}make lib1\char`\"{}. With Windows
and Visual C++ the DLL project builds an equivalent of lib1, and numerous examples
are provided in the DLL\_USE directory. The complete one channel mode interface
is given section 7.24. Let's exemplify the use below:

~

First, initialize the engine with a diphone database. All the functions in the
API return an error code. A negative value means there was a flaw during the
process, in case of error, an explicit error message can be obtained from \textbf{lastErrorStr\_MBR}().

\begin{quotation}
err\_code= init\_MBR(\char`\"{}h:/mbrola/database/fr1\char`\"{} );

if (err\_code<0) 

~~~~handle\_error();
\end{quotation}
If the default parser is plugged, one can use the regular syntax in write\_MBR
to send phonemes to the engine:

\begin{quotation}
if ( ( write\_MBR(\char`\"{}\_ 51 \char`\\{}n b 62 \char`\\{}n\char`\"{}) <
0) ||

( write\_MBR(\char`\"{}o\~{} 127 50 170 \char`\\{}n Z 110\char`\\{}n\char`\"{})
<0) ||

( WriteSpeechFile(output)<0) ||

( write\_MBR(\char`\"{}u 211 100 200\char`\\{}n R 150 \char`\\{}n\_ 9\char`\\{}n\#\char`\\{}n\char`\"{})
< 0) ||

( WriteSpeechFile(output)<0) )

~~~~~~~handle\_error();

close\_MBR();
\end{quotation}
Each time one calls \textbf{init\_MBR}(), one should call a pending \textbf{close\_MBR}()
to release allocated memory. Once \textbf{close\_MBR}() is called, one can call
init\_MBR() for a brand new database. If one wish to work with the same database
but forget previously entered phonemes, then use \textbf{reset\_MBR}().

~

Let's describe how \textbf{WriteSpeechFile} works:

\begin{quotation}
int WriteSpeechFile(FILE {*}output)

\{

int i;

while ( (i=readtype\_MBR(buffer, 16000, LIN16)) == 16000)

~~fwrite(buffer, 2, i, output);

if (i>0)

\{ /{*} write last chunk {*}/

~~fwrite(buffer,size,i,output);

~~return 0;

\}

else

~~return i; /{*} return an error code {*}/

\}
\end{quotation}
It reads sample buffers from the engine until it can't get any more ( \textbf{readtype\_MBR}
returns 0), or an error occurs. Readtype can return 0 for two reasons: either
a flush has been encountered, either we don't have enough data in the default
parser, as it needs a look ahead to interpolate pitch values. This is the case
after \textbf{write\_MBR}(\char`\"{}o\~{} 127 50 170 \char`\\{}n Z 110\char`\\{}n\char`\"{}),
synthesis on the /Z/ can't be carried out until we get the pitch point on \char`\"{}u
211 100 200\char`\"{}. This way asynchronous read/write operations are allowed.

~

The small error handling function simply does:

\begin{quotation}
void handle\_error()

\{

~~char err{[}255{]};

~~lastErrorStr\_MBR(err,sizeof(err));

~~printf(\char`\"{}Code \%i\char`\\{}n\%s\char`\\{}n\char`\"{}, lastError\_MBR(),
err);

~~exit(-1);

\}
\end{quotation}
At any time, one can use the get\_{*} and set\_{*} functions to modify internal
parameters of the synthesizer.

~

Important note about the vocal tract length capabilities: one can modify the
size of the speaker's throat with \textbf{setFreq\_MBR}. The lower this frequency,
the deeper the voice. This very simple method takes advantage of the playback
sampling rate to shift the formants up and down, just like when changing the
speed of a tape player. Thus, to be effective, any call to \textbf{setFreq\_MBR}
must be accompanied with a call to the audio hardware setting the requested
playback sample rate. Otherwise the speed and pitch will sound odd.


\subsubsection{Multi channel mode}

One can build a demo by running \char`\"{}\textbf{make demo2}\char`\"{} under
Unix, or simply build the library with \char`\"{}\textbf{make lib2}\char`\"{}.
The complete multi channel mode interface is given section 7.25. 

~

It looks strangely close to the one channel mode, except that one passes a pointer
to a synthesizer structure for every function. Another point is that it doesn't
hide any more the parser's details to the user. Thus if one wants to use the
default parser, one has to effectively build it. 

~

The following code build 3 independent default phoneme parsers: 

\begin{quotation}
/{*} Input Fifo with a buffer of 100 chars {*}/

fifo1= init\_Fifo(100);

fifo2= init\_Fifo(100);

fifo3= init\_Fifo(100);

~

/{*} Input stream of the synthesizer {*}/

input1= init\_InputFifo(fifo1);

input2= init\_InputFifo(fifo2);

input3= init\_InputFifo(fifo3);

/{*} Plug the fifos on the default parsers {*}/

parser1= init\_ParserInput(input1,\char`\"{}\_\char`\"{},120.0,\char`\"{};\char`\"{},1.0,1.0);

parser2= init\_ParserInput(input2,\char`\"{}\_\char`\"{},120.0,\char`\"{};\char`\"{},1.0,1.0);

parser3= init\_ParserInput(input3,\char`\"{}\_\char`\"{},120.0,\char`\"{};\char`\"{},1.0,1.0);
\end{quotation}
To use one's own parser, see the next section. Once this is done, as many databases
as synthesis channels must be opened (let's say 3 channels in this example).

\begin{quotation}
Database{*} main\_dba= init\_DatabaseMBR2(argv{[}1{]},NULL,NULL); 

if (!main\_dba)

~~~handle\_error(True);
\end{quotation}
Of course opening 3 or more times the same database would spoil a lot of memory
since many internal structures could be shared. Instead of using \textbf{init\_DatabaseMBR2}
one can clone an already opened database:

\begin{quotation}
Database{*} clone\_dba1= copyconstructor\_DatabaseMBR2(main\_dba);

Database{*} clone\_dba2= copyconstructor\_DatabaseMBR2(main\_dba);

Database{*} clone\_dba3= copyconstructor\_DatabaseMBR2(main\_dba);
\end{quotation}
Cloned database just behave like regular Database, i.e. their destructor must
be called before leaving. Once we have a Parser input and a Database, we can
open a synthesis channel:

\begin{quotation}
Mbrola{*} channel1= init\_MBR2(clone\_dba1,parser1);

Mbrola{*} channel2= init\_MBR2(clone\_dba2,parser2);

Mbrola{*} channel3= init\_MBR2(clone\_dba3,parser3);
\end{quotation}
In this particular example, one can write phonemes in the parser, and read samples
from the synthesis engine with instructions such as:

\begin{quotation}
write\_Fifo(fifo1,\char`\"{}\_ 51 \char`\\{}n b 62 \char`\\{}n o\~{} 100\char`\\{}n
Z 120\char`\"{})

while ((i=readtype\_MBR2(channel1, buffer, 16000, LIN16))==16000)

~~~fwrite(buffer,size,i,output);
\end{quotation}
Of course the call to write\_Fifo is completely dependent of the fact that this
example uses the default phoneme parser. In this particular case, the polymorphic
object Parser, which was passed to the constructor of channel, reads its input
data from Fifo1.


\subsubsection{Designing and plugging your own parser}

The user can write his own implementation of a Parser, as long as it follows
the definition of Parser/parser.h. The file parser\_simple.c below gives an
example of a parser that reads phonetic inputs with the format: Phoneme Duration
Pitch\_At\_0\% Pitch\_At\_100\%.

~

In practice this example does not take into account that the Engine synthesize
diphones. As the word states, a diphone is made of two phonemes, thus one must
know both parts of the diphones to utter it. Thus each phoneme file being used
with parser\_simple must end with two silences: the first one reveal 1st half
of the last phoneme, and the second one reveal the second half (a complete example
is provided in VisualC++/DLL\_USE/mbrola/parser\_simple.cpp). Many people forget
to include the second silence as the result sounds correct without. Though,
the total length of the synthetic message won't agree with the requested one.

\begin{quotation}
/{*}

{*} FPMs-TCTS SOFTWARE LIBRARY

{*}

{*} File: parser\_simple.c

{*} Purpose: parse a simple \char`\"{}pho file\char`\"{} (demonstration of the
mbrola DLL)

{*} Instanciation of parser.h

{*}

{*} Author: Vincent Pagel

{*} Email : mbrola@tcts.fpms.ac.be

{*}

{*} Copyright (c) 1995-2018 Faculte Polytechnique de Mons (TCTS lab)

{*}

{*} 18/09/98 : Created

{*}/

~

\#include <stdio.h>

\#include \char`\"{}mbrola.h\char`\"{}

\#include \char`\"{}parser\_simple.h\char`\"{}

~

static void reset\_ParserSimple(Parser{*} parse)

\{

/{*} nothing to do {*}/

fseek( (File{*}) parse->self,0,SEEK\_SET);

\}

~

static StatePhone nextphone\_ParserSimple(Parser{*} parse, LPPHONE{*} ph)

\{

~~char phoneme{[}255{]}; /{*} phoneme name {*}/

~~float length; /{*} length in milliseconds {*}/

~~float pitch0; /{*} pitch at 0\% {*}/

~~float pitch100; /{*} pitch at 100\% {*}/

~

~~if ( fscanf( (FILE{*})parse->self,\char`\"{} \%s \%f \%f \%f \char`\"{},phoneme,\&length,\&pitch0,\&pitch100
) ==4 )

~~\{

~~~~~~~{*}ph= init\_Phone(phoneme,length);

~~~~~~~~appendf0\_Phone({*}ph, 0.0 , pitch0);

~~~~~~~~appendf0\_Phone({*}ph, 100.0, pitch100);

~~~~~~~~return PHO\_OK;

~~\}

else

~~\{

~~~~~~~~~return PHO\_EOF;

~~\}

\}

~

static void close\_ParserSimple(Parser{*} parse)

~~~~~~~~ /{*} Destructor {*}/

\{

~~fclose( (FILE{*}) parse->self);

~~free(parse);

\}

~

Parser{*} init\_ParserSimple(char{*} input\_name)

/{*}

~~{*} Constructor of the parser. Parse a text file of the form

~~{*} PHONEME LENGTH PITCH\_AT\_BEGINNING PITCH\_AT\_END

~~{*}/

\{

~~FILE{*} input;

~~Parser{*} parse;

~

~~/{*} open the text file {*}/

~~input=fopen(input\_name,\char`\"{}rt\char`\"{});

~

~~if (!input)

~~~~~~~~ return NULL;

~

~~parse= (Parser{*}) MBR\_alloc( sizeof( struct Parser) );

~~parse->reset\_Parser= reset\_ParserSimple;

~~parse->close\_Parser= close\_ParserSimple;

~~parse->nextphone\_Parser= nextphone\_ParserSimple; 

~~parse->self= (void{*}) input;

~~return(parse);

\}
\end{quotation}

\subsection{Mbrola architecture}

In following chapters the exported functions and variables of all the source
files in the project are described. After the file descriptions, a symbol index
is provided to allow fast localization of any function, variable or define.

\end{document}
